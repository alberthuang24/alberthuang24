<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>theme on work4fun</title><link>https://albert.work4fun.io/tags/theme/</link><description>Recent content in theme on work4fun</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 16 Jun 2021 22:24:34 +0800</lastBuildDate><atom:link href="https://albert.work4fun.io/tags/theme/index.xml" rel="self" type="application/rss+xml"/><item><title>聊聊 “协程” Coroutine</title><link>https://albert.work4fun.io/posts/coroutine/</link><pubDate>Wed, 16 Jun 2021 22:24:34 +0800</pubDate><guid>https://albert.work4fun.io/posts/coroutine/</guid><description>最近问团队的小伙伴希望我写一些什么类型的文章给团队内学习的时候. 有人提到了golang的协程(因为现在很多小伙伴可能是php+golang).
在聊协程之前, 我们还是得先聊聊 并行(parallel) 跟 并发(concurrent). 那么什么是并发计算呢?
我们用gif图来解释. 方块变成紫色就表示cpu在处理一个子程序. 当我们的程序没有并发的时候. 它像这样. 每一秒只有当一个方块变成紫色后
另一个方块才能变成紫色. 就如同我们的CPU在单核的时候. 同一个时刻. 只能运行一个子程序. 这个时候我们会觉得. 程序好像很卡的样子. 每个方块等待的时间都很长.
这就是串行执行。
然后呢, 我们调整我们的程序. 让每一个方块在亮一刻之后. 将亮的权力交接给另一个方块. 两个不断的让出权力. 使我们觉得CPU好像可以同时把两个方块点亮.
这就是并发执行. 当然, 现实的计算机例子实现并发细节还有很多, 这里只是用简单的模型让大家理解
那么什么是并行呢, 现在的CPU大部分都是双核, 四核, 或者八核. 那前面我们也说了.
我们的CPU在单核的时候. 同一个时刻. 只能运行一个子程序.
所以当我们的CPU只有单核的时候, 我的理解是. 不存在并行执行. 那当我们的CPU是双核的时候. 我们就可以像下面的gif图一样. 每次可以亮起两个紫色方块。(截图就可以看到了)
这个就是并行执行。
ok, 大概理解了 并行(parallel) 跟 并发(concurrent) 后. 我们就可以聊聊. 我们今天讨论的主角. &amp;quot;协程&amp;quot; 了。
协程的概念很早就提出来了，但火起来, 我记得是因为golang火导致的. 其实golang中的goroutine跟很多语言里面的协程, 比如 php，javascript(新版v8引擎) 等这些语言的协程都不太一样. 所以golang的协程叫goroutine, 而不是 coroutine. 很多文章阐述 coroutine 跟 goroutine 的区别我个人觉得都不太正确.</description></item><item><title>一起来学 Shell 吧</title><link>https://albert.work4fun.io/posts/let-lean-shell/</link><pubDate>Tue, 16 Jun 2020 22:17:51 +0800</pubDate><guid>https://albert.work4fun.io/posts/let-lean-shell/</guid><description>我们现在大部分开发现在都是使用macos进行开发. macos由于是基于Unix系统开发的. 所以系统本身很好的支持了bash.（虽然不同系统下有些地方有些差异）. 这就使我们可以很方便的使用shell来优化我们的工作效率.
sh, bash, zsh, fish 是什么, 有什么区别 我个人的理解呢, 是这样的. 他们都属于shell, 但是他们所支持的语法糖跟一些高级特性, 比如命令补全. 这些不一样.
其中比较流行的就是bash. 所以我们在看到shell脚本基本都能看到一行 #!/bin/bash. 用来指定此脚本使用特定的sh来执行
我个人平时办公最常用的是zsh. 当然我推荐新手也用这个. 这个对于学习跟办公来说效率是最高的.
其中 sh 的大小是最小的. 所以大部分linux发行版本内置都是 sh.
如下我们可以看到. 除了 sh 才 31k . 其他外壳的sh都是几百k.
除了写一些嵌入式的时候需要考虑有限的存储跟内存用选用比较小的sh以外. 像我平时在公司的dockerfile都会特意安装一个bash
ls -lh /bin/ | grep sh -r-xr-xr-x 1 root wheel 609K Aug 11 04:56 bash -rwxr-xr-x 1 root wheel 517K Aug 11 04:56 csh -rwxr-xr-x 1 root wheel 108K Aug 11 04:56 dash -r-xr-xr-x 1 root wheel 1.</description></item><item><title>让你的代码更可读之 Table-driven</title><link>https://albert.work4fun.io/posts/table-driven/</link><pubDate>Wed, 24 Jun 2015 13:50:46 +0200</pubDate><guid>https://albert.work4fun.io/posts/table-driven/</guid><description>平时我们开发, 经常会遇到需要使用if, case的场景, 有时候阅读起来比较困难, 也不易于维护. 增加了修改的复杂性.
像比如我见过的有这样的.
const getCdnAssetOrigin = ({ isLocal, isDev, isPro, isDemo, isQa }) =&amp;gt; { let version = process.env.appVersion; let cdnOrigin = &amp;#39;&amp;#39;; if (isLocal) { cdnOrigin = &amp;#39;&amp;#39;; } else if (isPro) { cdnOrigin = &amp;#39;//other.wkcoding.com/cm_www/pro/&amp;#39;; } else if (isDemo) { cdnOrigin = &amp;#39;//other.wkcoding.com/cm_www/demo/&amp;#39;; } else if (isDev) { cdnOrigin = &amp;#39;//other.wkcoding.com/cm_www/dev/&amp;#39;; } if (version) { cdnOrigin = `${cdnOrigin}${version}/`; } return cdnOrigin; }; 还有这样的.
$xun_fei_text_2_audio = XunFeiText2AudioModule::instance(); switch ($type) { case XunFeiText2AudioModule::VOICE_NAME_LIST_TYPE[&amp;#39;all&amp;#39;]: $voice_name_list = $xun_fei_text_2_audio-&amp;gt;getAllVoiceNames(); break; case XunFeiText2AudioModule::VOICE_NAME_LIST_TYPE[&amp;#39;free&amp;#39;]: $voice_name_list = $xun_fei_text_2_audio-&amp;gt;getFreeVoiceNames(); break; case XunFeiText2AudioModule::VOICE_NAME_LIST_TYPE[&amp;#39;paid&amp;#39;]: $voice_name_list = $xun_fei_text_2_audio-&amp;gt;getPaidVoiceNames(); break; default: return $this-&amp;gt;error(&amp;#39;发音人不存在&amp;#39;); } 还有其他一些很复杂的情况, 上面只是列举最近我们团队在这两天code review发现的.</description></item></channel></rss>