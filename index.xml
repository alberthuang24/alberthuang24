<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>work4fun</title><link>https://albert.work4fun.io/</link><description>Recent content on work4fun</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 19 Jun 2021 13:50:46 +0200</lastBuildDate><atom:link href="https://albert.work4fun.io/index.xml" rel="self" type="application/rss+xml"/><item><title>英语好难呀</title><link>https://albert.work4fun.io/snippet/english-ishard/</link><pubDate>Sat, 19 Jun 2021 13:50:46 +0200</pubDate><guid>https://albert.work4fun.io/snippet/english-ishard/</guid><description>Oops&amp;hellip;今天又是痛苦学英语的第N天。
我感觉我不搞明白这些原理我没法很快的将英语学的比较好。
就比如我在读这段话的时候我心里挺别扭的。
Make sure all the checkboxes at the bottom are not checked. 确认所有的复选框在底部是未选中的... egg... 当然我全部读完后心中重新组织一遍会知道正确的应该是
确认在底部的所有复选框都没有被选中... 但是我心中很别扭。因为每句话我都需要全部读完后在内心重新组织一遍。</description></item><item><title>WeSplit: 了解基本的SwiftUI结构</title><link>https://albert.work4fun.io/swift-ui-wesplit/2%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 19 Jun 2021 18:00:21 +0800</pubDate><guid>https://albert.work4fun.io/swift-ui-wesplit/2%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</guid><description>当你创建了一个 SwiftUI 应用, 你将得到一个一些文件，也许有 100 多行代码。
大部分代码没有什么作用，只是作为占位符给你填一些东西 - 现在你可以暂时忽略它们，但是后面的课程会需要使用到他们。
你可以在 Xcode 左边栏看到一些文件，这叫项目导航栏：
AppDelegate.swift 包含管理应用程序的代码，以前经常会在这里添加代码，但是现在很少。 SceneDelegate.swift 还有应用启动窗口的代码，这些在 iPhone 没什么用，但是在 iPad - 哪些用户可以在任意时间拥有多个实例 - 这很重要 ContentView.swift 包含你的程序最初始的用户界面，这也是我们将在这个项目做的所有工作。 Assets.xcassets 是一个资源目录 - 你想在这个程序使用的图片集合。你也可以在这里添加颜色，应用的 icons，iMessage 的贴纸，以及更多。 LaunchScreen.storyboard 是一个创建应用启动界面的视图编辑器。 Info.plist 是一个关注你的应用如何在系统工作的特殊值集合 - 当前应用是哪个版本，支持哪些设备方向，以及更多。 这些不是代码，但是很重要。 Preview Content 是一个内部使用 Preview Assets.xcassets 单独资源目录，这里专门给您存放想要设计用户界面时的示例图片，让你看看程序运行时候的样子。 我们在这里项目的所有工作都将在 ContentView.swift 进行，其中 Xcode 将已经打开给你。
在顶部有一些注释 - 在开始的地方标记了两个斜线的东西 - Swift 会忽略他们，所以你可以使用他们来解释关于你的代码如何工作。
注释下面是十来行的代码：
import SwiftUI struct ContentView: View { var body: some View { Text(&amp;#34;Hello World&amp;#34;) } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } 我们在开始写代码之前，让我们看看这些代码的作用。</description></item><item><title>xcode-tools 在每次系统更新后的问题</title><link>https://albert.work4fun.io/snippet/gyp-mac-xcode/</link><pubDate>Thu, 17 Jun 2021 13:50:46 +0200</pubDate><guid>https://albert.work4fun.io/snippet/gyp-mac-xcode/</guid><description>Oops&amp;hellip;今天又遇到 gyp 报错了.. 记得明明安装过 xcode-tools..
No receipt for &amp;#39;com.apple.pkg.CLTools_Executables&amp;#39; found at &amp;#39;/&amp;#39;. No receipt for &amp;#39;com.apple.pkg.DeveloperToolsCLILeo&amp;#39; found at &amp;#39;/&amp;#39;. No receipt for &amp;#39;com.apple.pkg.DeveloperToolsCLI&amp;#39; found at &amp;#39;/&amp;#39;. gyp: No Xcode or CLT version detected! gyp ERR! configure error gyp ERR! stack Error: `gyp` failed with exit code: 1 gyp ERR! stack at ChildProcess.onCpExit (/Users/alberthuang/.nvm/versions/node/v10.24.1/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16) gyp ERR! stack at ChildProcess.emit (events.js:198:13) gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:248:12) gyp ERR! System Darwin 20.5.0 gyp ERR!</description></item><item><title>聊聊 “协程” Coroutine</title><link>https://albert.work4fun.io/posts/coroutine/</link><pubDate>Wed, 16 Jun 2021 22:24:34 +0800</pubDate><guid>https://albert.work4fun.io/posts/coroutine/</guid><description>最近问团队的小伙伴希望我写一些什么类型的文章给团队内学习的时候. 有人提到了golang的协程(因为现在很多小伙伴可能是php+golang).
在聊协程之前, 我们还是得先聊聊 并行(parallel) 跟 并发(concurrent). 那么什么是并发计算呢?
我们用gif图来解释. 方块变成紫色就表示cpu在处理一个子程序. 当我们的程序没有并发的时候. 它像这样. 每一秒只有当一个方块变成紫色后
另一个方块才能变成紫色. 就如同我们的CPU在单核的时候. 同一个时刻. 只能运行一个子程序. 这个时候我们会觉得. 程序好像很卡的样子. 每个方块等待的时间都很长.
这就是串行执行。
然后呢, 我们调整我们的程序. 让每一个方块在亮一刻之后. 将亮的权力交接给另一个方块. 两个不断的让出权力. 使我们觉得CPU好像可以同时把两个方块点亮.
这就是并发执行. 当然, 现实的计算机例子实现并发细节还有很多, 这里只是用简单的模型让大家理解
那么什么是并行呢, 现在的CPU大部分都是双核, 四核, 或者八核. 那前面我们也说了.
我们的CPU在单核的时候. 同一个时刻. 只能运行一个子程序.
所以当我们的CPU只有单核的时候, 我的理解是. 不存在并行执行. 那当我们的CPU是双核的时候. 我们就可以像下面的gif图一样. 每次可以亮起两个紫色方块。(截图就可以看到了)
这个就是并行执行。
ok, 大概理解了 并行(parallel) 跟 并发(concurrent) 后. 我们就可以聊聊. 我们今天讨论的主角. &amp;quot;协程&amp;quot; 了。
协程的概念很早就提出来了，但火起来, 我记得是因为golang火导致的. 其实golang中的goroutine跟很多语言里面的协程, 比如 php，javascript(新版v8引擎) 等这些语言的协程都不太一样. 所以golang的协程叫goroutine, 而不是 coroutine. 很多文章阐述 coroutine 跟 goroutine 的区别我个人觉得都不太正确.</description></item><item><title>WeSplit: 项目简介</title><link>https://albert.work4fun.io/swift-ui-wesplit/1%E7%AE%80%E4%BB%8B/</link><pubDate>Wed, 16 Jun 2021 18:00:21 +0800</pubDate><guid>https://albert.work4fun.io/swift-ui-wesplit/1%E7%AE%80%E4%BB%8B/</guid><description>在这个项目中，我们将构建一个用于在餐厅吃饭的费用确认 app。 你可以输入你的食材成本，选择你想给多少小费，以及多少人用餐， app将告诉你每个人需要AA多少钱。
这个项目不是尝试构建一个复杂的东西，因为它的真实目的是, 在一个真实世界项目中以有用的方式教你基本的SwiftUI, 如果你想进更进一步, 你可以扩展。
你将学习基础的UI设计，如何让用户输入一个值以及选择一个选项， 并且如何跟踪程序状态。
由于这是第一个项目，我们将顺利的慢慢进行，并且解释发生的一切 - 后面的项目将慢慢的增加速度， 但是现在我们需要轻松一点。
这个项目 - 像是所有构建一个完整的应用程序应用的项目一样 - 分解为三个步骤：
对你将要学习的技术进行实践性的介绍。 一步步的引导构建项目。 需要你自己完成的挑战，以进一步推动该项目。 每一步都非常重要，所以不要尝试去跳过任何一步。
在第一步我们将学习创建独立的组件，然后你可以知道这些是如何独立工作的。
这将有大量的代码，但是也会进行一些解释，这样你就可以看到一切是如何工作的。
当前这一步是一个概览：下面是我们将要使用的东西，它们是如何工作的，以及如何使用它们。
在第二步, 我们将讨论这些概念并且将其应用到真实项目当中。
在这里，你将看到他们实际是如何工作的，但是你也将获取到更多到背景信息 - 为什么我们会想使用他们，以及如何使用更多到组件将他们组合到一起。
总之, 是时候开始我们的第一个项目了，我们将要看看以下构建一个“费用确认”app所需要的技术，然后如何在真实项目使用它。
所以, 现在启动Xcode，并且选择创建一个新的Xcode项目。
你将看到一个显示列表，并且我想让你选择“单视图”(single view)的 iOS App，下一步，你需要做以下工作：
给项目名称(Product Name)输入 “WeSplit”。 给组织标识(Organization Identifier)输入任意字符，但是如果你拥有一个站点，你应该反着输入： 比如 “hackingwithswift.com” 应该输入 “com.hackingwithswift”。如果你没有域名，编一个就好了。 确认语言一览选择的是 Swift。 用户界面请选择 SwiftUI。 请确保底部的复选框都没有被选中。 让我们开始把！
References 本文翻译自 https://www.hackingwithswift.com/books/ios-swiftui. 感谢原作者 @twostraws.</description></item><item><title>一起来学 Shell 吧</title><link>https://albert.work4fun.io/posts/let-lean-shell/</link><pubDate>Tue, 16 Jun 2020 22:17:51 +0800</pubDate><guid>https://albert.work4fun.io/posts/let-lean-shell/</guid><description>it 我们现在大部分开发现在都是使用macos进行开发. macos由于是基于Unix系统开发的. 所以系统本身很好的支持了bash.（虽然不同系统下有些地方有些差异）. 这就使我们可以很方便的使用shell来优化我们的工作效率.
sh, bash, zsh, fish 是什么, 有什么区别 我个人的理解呢, 是这样的. 他们都属于shell, 但是他们所支持的语法糖跟一些高级特性, 比如命令补全. 这些不一样.
其中比较流行的就是bash. 所以我们在看到shell脚本基本都能看到一行 #!/bin/bash. 用来指定此脚本使用特定的sh来执行
我个人平时办公最常用的是zsh. 当然我推荐新手也用这个. 这个对于学习跟办公来说效率是最高的.
其中 sh 的大小是最小的. 所以大部分linux发行版本内置都是 sh.
如下我们可以看到. 除了 sh 才 31k . 其他外壳的sh都是几百k.
除了写一些嵌入式的时候需要考虑有限的存储跟内存用选用比较小的sh以外. 像我平时在公司的dockerfile都会特意安装一个bash
ls -lh /bin/ | grep sh -r-xr-xr-x 1 root wheel 609K Aug 11 04:56 bash -rwxr-xr-x 1 root wheel 517K Aug 11 04:56 csh -rwxr-xr-x 1 root wheel 108K Aug 11 04:56 dash -r-xr-xr-x 1 root wheel 1.</description></item><item><title>让你的代码更可读之 Table-driven</title><link>https://albert.work4fun.io/posts/table-driven/</link><pubDate>Wed, 24 Jun 2015 13:50:46 +0200</pubDate><guid>https://albert.work4fun.io/posts/table-driven/</guid><description>平时我们开发, 经常会遇到需要使用if, case的场景, 有时候阅读起来比较困难, 也不易于维护. 增加了修改的复杂性.
像比如我见过的有这样的.
const getCdnAssetOrigin = ({ isLocal, isDev, isPro, isDemo, isQa }) =&amp;gt; { let version = process.env.appVersion; let cdnOrigin = &amp;#39;&amp;#39;; if (isLocal) { cdnOrigin = &amp;#39;&amp;#39;; } else if (isPro) { cdnOrigin = &amp;#39;//other.wkcoding.com/cm_www/pro/&amp;#39;; } else if (isDemo) { cdnOrigin = &amp;#39;//other.wkcoding.com/cm_www/demo/&amp;#39;; } else if (isDev) { cdnOrigin = &amp;#39;//other.wkcoding.com/cm_www/dev/&amp;#39;; } if (version) { cdnOrigin = `${cdnOrigin}${version}/`; } return cdnOrigin; }; 还有这样的.
$xun_fei_text_2_audio = XunFeiText2AudioModule::instance(); switch ($type) { case XunFeiText2AudioModule::VOICE_NAME_LIST_TYPE[&amp;#39;all&amp;#39;]: $voice_name_list = $xun_fei_text_2_audio-&amp;gt;getAllVoiceNames(); break; case XunFeiText2AudioModule::VOICE_NAME_LIST_TYPE[&amp;#39;free&amp;#39;]: $voice_name_list = $xun_fei_text_2_audio-&amp;gt;getFreeVoiceNames(); break; case XunFeiText2AudioModule::VOICE_NAME_LIST_TYPE[&amp;#39;paid&amp;#39;]: $voice_name_list = $xun_fei_text_2_audio-&amp;gt;getPaidVoiceNames(); break; default: return $this-&amp;gt;error(&amp;#39;发音人不存在&amp;#39;); } 还有其他一些很复杂的情况, 上面只是列举最近我们团队在这两天code review发现的.</description></item></channel></rss>